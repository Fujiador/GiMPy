%
% API Documentation for API Documentation
% Module coinor.gimpy.graph
%
% Generated by epydoc 3.0.1
% [Fri Apr 04 15:14:39 2014]
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                          Module Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}|(}
\section{Module coinor.gimpy.graph}

    \label{coinor:gimpy:graph}
\begin{alltt}

A Graph class implementation. The aim for this implementation is
1. To reflect implementation methods in literature as much as possible
3. To have something close to a "classic" object-oriented design
(compared to previous versions)

This implementation can be considered as a compromise between a graph
class designed for visualization and an efficient graph data structure.

One deviation from standard Graph implementations is to keep in neighbors in
an other adjacency list. We do this for efficiency reasons considering
traversing residual graphs.

We have a class for Graph and a class for Node. Edges are not represented as
objects. They are kept in a dictionary which also keeps their attributes.

Graph display related methods are inspired from Pydot. They are re-written
considering GIMPy needs. We also borrow two methods from Pydot, see
global\_constants.py for details.

Default graph type is an undirected graph.

No custom exception will raise when the user tries to get in\_neighbors of an
undirected graph. She should be aware of this. Python will raise an exception
since user is trying to read an attribute that does not exits.

Methods that implement algorithms has display argument in their API. If this
argument is not specified global display setting will be used for display
purposes of the algorithm method implements. You can use display argument to
get visualization of algorithm without changing global display behavior of your
Graph/Tree object.

Method documentation strings are orginized as follows.
API: method\_name(arguments)
Description: Description of the method.
Input: Arguments and their explanation.
Pre: Necessary class attributes that should exists, methods to be called
     before this method.
Post: Class attributes changed within the method.
Return: Return value of the method.

TODO(aykut):
-{\textgreater} svg display mode
-{\textgreater} label\_strong\_components() API change. Check backward compatibilty.
-{\textgreater} dfs should use search()?
-{\textgreater} display mode svg is not supported.
future:
-{\textgreater} The solution we find is not strongly feasible. Fix this.
\end{alltt}

\textbf{Version:} 1.1.1



\textbf{Author:} Ted Ralphs, Aykut Bulut (ted@lehigh.edu, aykut@lehigh.edu)



\textbf{License:} BSD




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               Variables                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsection{Variables}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\raggedright \_\-\_\-m\-a\-i\-n\-t\-a\-i\-n\-e\-r\-\_\-\_\- & \raggedright \textbf{Value:} 
{\tt \texttt{'}\texttt{Aykut Bulut}\texttt{'}}&\\
\cline{1-2}
\raggedright \_\-\_\-e\-m\-a\-i\-l\-\_\-\_\- & \raggedright \textbf{Value:} 
{\tt \texttt{'}\texttt{aykut@lehigh.edu}\texttt{'}}&\\
\cline{1-2}
\raggedright \_\-\_\-u\-r\-l\-\_\-\_\- & \raggedright \textbf{Value:} 
{\tt None}&\\
\cline{1-2}
\raggedright \_\-\_\-t\-i\-t\-l\-e\-\_\-\_\- & \raggedright \textbf{Value:} 
{\tt \texttt{'}\texttt{Linked list data structure}\texttt{'}}&\\
\cline{1-2}
\raggedright P\-Y\-G\-A\-M\-E\-\_\-I\-N\-S\-T\-A\-L\-L\-E\-D\- & \raggedright \textbf{Value:} 
{\tt True}&\\
\cline{1-2}
\raggedright D\-O\-T\-2\-T\-E\-X\-\_\-I\-N\-S\-T\-A\-L\-L\-E\-D\- & \raggedright \textbf{Value:} 
{\tt True}&\\
\cline{1-2}
\raggedright P\-I\-L\-\_\-I\-N\-S\-T\-A\-L\-L\-E\-D\- & \raggedright \textbf{Value:} 
{\tt True}&\\
\cline{1-2}
\raggedright X\-D\-O\-T\-\_\-I\-N\-S\-T\-A\-L\-L\-E\-D\- & \raggedright \textbf{Value:} 
{\tt True}&\\
\cline{1-2}
\raggedright E\-T\-R\-E\-E\-\_\-I\-N\-S\-T\-A\-L\-L\-E\-D\- & \raggedright \textbf{Value:} 
{\tt True}&\\
\cline{1-2}
\raggedright C\-L\-U\-S\-T\-E\-R\-\_\-A\-T\-T\-R\-I\-B\-U\-T\-E\-S\- & \raggedright \textbf{Value:} 
{\tt \texttt{set([}\texttt{'}\texttt{K}\texttt{'}\texttt{, }\texttt{'}\texttt{URL}\texttt{'}\texttt{, }\texttt{'}\texttt{bgcolor}\texttt{'}\texttt{, }\texttt{'}\texttt{color}\texttt{'}\texttt{, }\texttt{'}\texttt{colorscheme}\texttt{'}\texttt{, }\texttt{'}\texttt{fill}\texttt{...}}&\\
\cline{1-2}
\raggedright D\-E\-F\-A\-U\-L\-T\-\_\-E\-D\-G\-E\-\_\-A\-T\-T\-R\-I\-B\-U\-T\-E\-S\- & \raggedright \textbf{Value:} 
{\tt \texttt{\{}\texttt{\}}}&\\
\cline{1-2}
\raggedright D\-E\-F\-A\-U\-L\-T\-\_\-G\-R\-A\-P\-H\-\_\-A\-T\-T\-R\-I\-B\-U\-T\-E\-S\- & \raggedright \textbf{Value:} 
{\tt \texttt{\{}\texttt{\}}}&\\
\cline{1-2}
\raggedright D\-E\-F\-A\-U\-L\-T\-\_\-N\-O\-D\-E\-\_\-A\-T\-T\-R\-I\-B\-U\-T\-E\-S\- & \raggedright \textbf{Value:} 
{\tt \texttt{\{}\texttt{\}}}&\\
\cline{1-2}
\raggedright D\-I\-R\-E\-C\-T\-E\-D\-\_\-G\-R\-A\-P\-H\- & \raggedright \textbf{Value:} 
{\tt \texttt{'}\texttt{digraph}\texttt{'}}&\\
\cline{1-2}
\raggedright D\-O\-T\-2\-T\-E\-X\-\_\-T\-E\-M\-P\-L\-A\-T\-E\- & \raggedright \textbf{Value:} 
{\tt \texttt{'}\texttt{{\textbackslash}n{\textbackslash}{\textbackslash}documentclass[landscape]\{article\}{\textbackslash}n{\textbackslash}{\textbackslash}usepackage[x11n}\texttt{...}}&\\
\cline{1-2}
\raggedright D\-O\-T\-\_\-K\-E\-Y\-W\-O\-R\-D\-S\- & \raggedright \textbf{Value:} 
{\tt \texttt{[}\texttt{'}\texttt{graph}\texttt{'}\texttt{, }\texttt{'}\texttt{subgraph}\texttt{'}\texttt{, }\texttt{'}\texttt{digraph}\texttt{'}\texttt{, }\texttt{'}\texttt{node}\texttt{'}\texttt{, }\texttt{'}\texttt{edge}\texttt{'}\texttt{, }\texttt{'}\texttt{strict}\texttt{'}\texttt{]}}&\\
\cline{1-2}
\raggedright E\-D\-G\-E\-\_\-A\-T\-T\-R\-I\-B\-U\-T\-E\-S\- & \raggedright \textbf{Value:} 
{\tt \texttt{set([}\texttt{'}\texttt{URL}\texttt{'}\texttt{, }\texttt{'}\texttt{arrowhead}\texttt{'}\texttt{, }\texttt{'}\texttt{arrowsize}\texttt{'}\texttt{, }\texttt{'}\texttt{arrowtail}\texttt{'}\texttt{, }\texttt{'}\texttt{color}\texttt{...}}&\\
\cline{1-2}
\raggedright E\-D\-G\-E\-\_\-C\-O\-N\-N\-E\-C\-T\-\_\-S\-Y\-M\-B\-O\-L\- & \raggedright \textbf{Value:} 
{\tt \texttt{\{}\texttt{'}\texttt{digraph}\texttt{'}\texttt{: }\texttt{'}\texttt{ -{\textgreater} }\texttt{'}\texttt{, }\texttt{'}\texttt{graph}\texttt{'}\texttt{: }\texttt{'}\texttt{ -- }\texttt{'}\texttt{\}}}&\\
\cline{1-2}
\raggedright G\-R\-A\-P\-H\-\_\-A\-T\-T\-R\-I\-B\-U\-T\-E\-S\- & \raggedright \textbf{Value:} 
{\tt \texttt{set([}\texttt{'}\texttt{Damping}\texttt{'}\texttt{, }\texttt{'}\texttt{K}\texttt{'}\texttt{, }\texttt{'}\texttt{URL}\texttt{'}\texttt{, }\texttt{'}\texttt{aspect}\texttt{'}\texttt{, }\texttt{'}\texttt{bb}\texttt{'}\texttt{, }\texttt{'}\texttt{bgcolor}\texttt{'}\texttt{, }\texttt{'}\texttt{c}\texttt{...}}&\\
\cline{1-2}
\raggedright I\-D\-\_\-R\-E\-\_\-A\-L\-P\-H\-A\-\_\-N\-U\-M\-S\- & \raggedright \textbf{Value:} 
{\tt re.compile(r'\texttt{(?u)}{\textasciicircum}\texttt{[}\_a\texttt{-}zA\texttt{-}Z\texttt{]}\texttt{[}a\texttt{-}zA\texttt{-}Z0\texttt{-}9\_,\texttt{]}\texttt{*}\$')}&\\
\cline{1-2}
\raggedright I\-D\-\_\-R\-E\-\_\-A\-L\-P\-H\-A\-\_\-N\-U\-M\-S\-\_\-W\-I\-T\-H\-\_\-P\-O\-R\-T\-S\- & \raggedright \textbf{Value:} 
{\tt re.compile(r'\texttt{(?u)}{\textasciicircum}\texttt{[}\_a\texttt{-}zA\texttt{-}Z\texttt{]}\texttt{[}a\texttt{-}zA\texttt{-}Z0\texttt{-}9\_,:"\texttt{]}\texttt{*}\texttt{[}a\texttt{-}zA\texttt{-}Z0\texttt{-}9\_,"\texttt{]}\texttt{...}}&\\
\cline{1-2}
\raggedright I\-D\-\_\-R\-E\-\_\-D\-B\-L\-\_\-Q\-U\-O\-T\-E\-D\- & \raggedright \textbf{Value:} 
{\tt re.compile(r'\texttt{(?su)}{\textasciicircum}".\texttt{*}"\$')}&\\
\cline{1-2}
\raggedright I\-D\-\_\-R\-E\-\_\-H\-T\-M\-L\- & \raggedright \textbf{Value:} 
{\tt re.compile(r'\texttt{(?su)}{\textasciicircum}{\textless}.\texttt{*}{\textgreater}\$')}&\\
\cline{1-2}
\raggedright I\-D\-\_\-R\-E\-\_\-N\-U\-M\- & \raggedright \textbf{Value:} 
{\tt re.compile(r'\texttt{(?u)}{\textasciicircum}\texttt{[}0\texttt{-}9,\texttt{]}\texttt{+}\$')}&\\
\cline{1-2}
\raggedright I\-D\-\_\-R\-E\-\_\-W\-I\-T\-H\-\_\-P\-O\-R\-T\- & \raggedright \textbf{Value:} 
{\tt re.compile(r'\texttt{(?u)}{\textasciicircum}\texttt{(}\texttt{[{\textasciicircum}}:\texttt{]}\texttt{*}\texttt{)}:\texttt{(}\texttt{[{\textasciicircum}}:\texttt{]}\texttt{*}\texttt{)}\$')}&\\
\cline{1-2}
\raggedright I\-N\-F\- & \raggedright \textbf{Value:} 
{\tt 10000}&\\
\cline{1-2}
\raggedright N\-O\-D\-E\-\_\-A\-T\-T\-R\-I\-B\-U\-T\-E\-S\- & \raggedright \textbf{Value:} 
{\tt \texttt{set([}\texttt{'}\texttt{URL}\texttt{'}\texttt{, }\texttt{'}\texttt{color}\texttt{'}\texttt{, }\texttt{'}\texttt{colorscheme}\texttt{'}\texttt{, }\texttt{'}\texttt{comment}\texttt{'}\texttt{, }\texttt{'}\texttt{distortio}\texttt{...}}&\\
\cline{1-2}
\raggedright U\-N\-D\-I\-R\-E\-C\-T\-E\-D\-\_\-G\-R\-A\-P\-H\- & \raggedright \textbf{Value:} 
{\tt \texttt{'}\texttt{graph}\texttt{'}}&\\
\cline{1-2}
\raggedright \_\-\_\-p\-a\-c\-k\-a\-g\-e\-\_\-\_\- & \raggedright \textbf{Value:} 
{\tt \texttt{'}\texttt{coinor.gimpy}\texttt{'}}&\\
\cline{1-2}
\end{longtable}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Node \textit{(class)}|(}
\subsection{Class Node}

    \label{coinor:gimpy:graph:Node}
\begin{tabular}{cccccc}
% Line for object, linespec=[False]
\multicolumn{2}{r}{\settowidth{\BCL}{object}\multirow{2}{\BCL}{object}}
&&
  \\\cline{3-3}
  &&\multicolumn{1}{c|}{}
&&
  \\
&&\multicolumn{2}{l}{\textbf{coinor.gimpy.graph.Node}}
\end{tabular}

Node class. A node object keeps node attributes. Has a method to write node
in Dot language grammer.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_init\_\_}(\textit{self}, \textit{name}, **\textit{attr})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: \_\_init\_\_(self, name, **attrs)
Description:
Node class constructor. Sets name and attributes using arguments.
Input:
    name: Name of node.
    **attrs: Node attributes.
Post:
    Sets self.name and self.attr.
\end{alltt}

\setlength{\parskip}{1ex}
      Overrides: object.\_\_init\_\_

    \end{boxedminipage}

    \label{coinor:gimpy:graph:Node:get_attr}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Node \textit{(class)}!coinor.gimpy.graph.Node.get\_attr \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_attr}(\textit{self}, \textit{attr})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: get\_attr(self, attr)
Description:
Returns node attribute attr.
Input:
    attr: Node attribute to get.
Return:
    Returns Node attribute attr if exists returns None, otherwise.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Node:set_attr}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Node \textit{(class)}!coinor.gimpy.graph.Node.set\_attr \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{set\_attr}(\textit{self}, \textit{attr}, \textit{value})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: set\_attr(self, attr, value)
Description:
Sets node attribute attr to value.
Input:
    attr: Node attribute to set.
    value: New value of the attribute.
Post:
    Updates self.attr[attr].
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Node:to_string}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Node \textit{(class)}!coinor.gimpy.graph.Node.to\_string \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{to\_string}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: to\_string(self)
Description:
Returns string representation of node in dot language.
Return:
    String representation of node.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_repr\_\_}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: \_\_repr\_\_(self)
Description:
Returns string representation of node in dot language.
Return:
    String representation of node.
\end{alltt}

\setlength{\parskip}{1ex}
      Overrides: object.\_\_repr\_\_

    \end{boxedminipage}


\large{\textbf{\textit{Inherited from object}}}

\begin{quote}
\_\_delattr\_\_(), \_\_format\_\_(), \_\_getattribute\_\_(), \_\_hash\_\_(), \_\_new\_\_(), \_\_reduce\_\_(), \_\_reduce\_ex\_\_(), \_\_setattr\_\_(), \_\_sizeof\_\_(), \_\_str\_\_(), \_\_subclasshook\_\_()
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                              Properties                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Properties}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\multicolumn{2}{|l|}{\textit{Inherited from object}}\\
\multicolumn{2}{|p{\varwidth}|}{\raggedright \_\_class\_\_}\\
\cline{1-2}
\end{longtable}

    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Node \textit{(class)}|)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}|(}
\subsection{Class Graph}

    \label{coinor:gimpy:graph:Graph}
\begin{tabular}{cccccc}
% Line for object, linespec=[False]
\multicolumn{2}{r}{\settowidth{\BCL}{object}\multirow{2}{\BCL}{object}}
&&
  \\\cline{3-3}
  &&\multicolumn{1}{c|}{}
&&
  \\
&&\multicolumn{2}{l}{\textbf{coinor.gimpy.graph.Graph}}
\end{tabular}

\textbf{Known Subclasses:}
coinor.gimpy.tree.Tree,
    coinor.gimpy.graph.DisjointSet

Graph class, implemented using adjacency list. See GIMPy README for more 
information.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_init\_\_}(\textit{self}, **\textit{attr})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: \_\_init\_\_(self, **attrs)
Description:
Graph class constructor. Sets attributes using argument.
Input:
    **attrs: Graph attributes.
Post:
    Sets following attributes using **attrs; self.attr,
    self.graph\_type. Creates following initial attributes;
    self.neighbors, self.in\_neighbors, self.nodes, self.out\_neighbors,
    self.cluster
\end{alltt}

\setlength{\parskip}{1ex}
      Overrides: object.\_\_init\_\_

    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_repr\_\_}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: \_\_repr\_\_(self)
Description:
Returns string representation of the graph.
Return:
    String representation of the graph.
\end{alltt}

\setlength{\parskip}{1ex}
      Overrides: object.\_\_repr\_\_

    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:add_node}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.add\_node \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{add\_node}(\textit{self}, \textit{name}, **\textit{attr})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: add\_node(self, name, **attr)
Description:
Adds node to the graph.
Pre:
    Graph should not contain a node with this name. We do not allow
    multiple nodes with the same name.
Input:
    name: Name of the node.
    attr: Node attributes.
Post:
    self.neighbors, self.nodes and self.in\_neighbors are updated.
Return:
    Node (a Node class instance) added to the graph.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:del_node}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.del\_node \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{del\_node}(\textit{self}, \textit{name})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: del\_node(self, name)
Description:
Removes node from Graph.
Input:
    name: Name of the node.
Pre:
    Graph should contain a node with this name.
Post:
    self.neighbors, self.nodes and self.in\_neighbors are updated.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:add_edge}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.add\_edge \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{add\_edge}(\textit{self}, \textit{name1}, \textit{name2}, **\textit{attr})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: add\_edge(self, name1, name2, **attr)
Description:
Adds edge to the graph. Sets edge attributes using attr argument.
Input:
    name1: Name of the source node (if directed).
    name2: Name of the sink node (if directed).
    attr: Edge attributes.
Pre:
    Graph should not already contain this edge. We do not allow
    multiple edges with same source and sink nodes.
Post:
    self.edge\_attr is updated.
    self.neighbors, self.nodes and self.in\_neighbors are updated if
    graph was missing at least one of the nodes.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:del_edge}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.del\_edge \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{del\_edge}(\textit{self}, \textit{e})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: del\_edge(self, e)
Description:
Removes edge from graph.
Input:
    e: Tuple that represents edge, in (source,sink) form.
Pre:
    Graph should contain this edge.
Post:
    self.edge\_attr, self.neighbors and self.in\_neighbors are updated.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:get_node}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.get\_node \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_node}(\textit{self}, \textit{name})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: get\_node(self, name)
Description:
Returns node object with the provided name.
Input:
    name: Name of the node.
Return:
    Returns node object if node exists, returns None otherwise.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:get_edge_cost}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.get\_edge\_cost \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_edge\_cost}(\textit{self}, \textit{edge})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: get\_edge\_cost(self, edge)
Description:
Returns cost attr of edge, required for minimum\_spanning\_tree\_kruskal().
Input:
    edge: Tuple that represents edge, in (source,sink) form.
Return:
    Returns cost attribute value of the edge.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:check_edge}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.check\_edge \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{check\_edge}(\textit{self}, \textit{name1}, \textit{name2})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: check\_edge(self, name1, name2)
Description:
Return True if edge exists, False otherwise.
Input:
    name1: name of the source node.
    name2: name of the sink node.
Return:
    Returns True if edge exists, False otherwise.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:get_node_list}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.get\_node\_list \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_node\_list}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: get\_node\_list(self)
Description:
Returns node list.
Return:
    List of nodes.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:get_edge_list}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.get\_edge\_list \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_edge\_list}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: get\_edge\_list(self)
Description:
Returns edge list.
Return:
    List of edges, edges are tuples and in (source,sink) format.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:get_node_num}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.get\_node\_num \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_node\_num}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: get\_node\_num(self)
Description:
Returns number of nodes.
Return:
    Number of nodes.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:get_edge_num}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.get\_edge\_num \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_edge\_num}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: get\_edge\_num(self)
Description:
Returns number of edges.
Return:
    Number of edges.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:get_node_attr}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.get\_node\_attr \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_node\_attr}(\textit{self}, \textit{name}, \textit{attr})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: get\_node\_attr(self, name, attr)
Description:
Returns attribute attr of given node.
Input:
    name: Name of node.
    attr: Attribute of node.
Pre:
    Graph should have this node.
Return:
    Value of node attribute attr.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:get_edge_attr}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.get\_edge\_attr \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_edge\_attr}(\textit{self}, \textit{n}, \textit{m}, \textit{attr})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: get\_edge\_attr(self, n, m, attr)
Description:
Returns attribute attr of edge (n,m).
Input:
    n: Source node name.
    m: Sink node name.
    attr: Attribute of edge.
Pre:
    Graph should have this edge.
Return:
    Value of edge attribute attr.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:set_node_attr}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.set\_node\_attr \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{set\_node\_attr}(\textit{self}, \textit{name}, \textit{attr}, \textit{value})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: set\_node\_attr(self, name, attr)
Description:
Sets attr attribute of node named name to value.
Input:
    name: Name of node.
    attr: Attribute of node to set.
Pre:
    Graph should have this node.
Post:
    Node attribute will be updated.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:set_edge_attr}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.set\_edge\_attr \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{set\_edge\_attr}(\textit{self}, \textit{n}, \textit{m}, \textit{attr}, \textit{value})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: set\_edge\_attr(self, n, m, attr, value)
Description:
Sets attr attribute of edge (n,m) to value.
Input:
    n: Source node name.
    m: Sink node name.
    attr: Attribute of edge to set.
    value: New value of attribute.
Pre:
    Graph should have this edge.
Post:
    Edge attribute will be updated.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:get_neighbors}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.get\_neighbors \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_neighbors}(\textit{self}, \textit{name})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: get\_neighbors(self, name)
Description:
Returns list of neighbors of given node.
Input:
    name: Node name.
Pre:
    Graph should have this node.
Return:
    List of neighbor node names.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:get_in_neighbors}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.get\_in\_neighbors \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_in\_neighbors}(\textit{self}, \textit{name})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: get\_in\_neighbors(self, name)
Description:
Returns list of in neighbors of given node.
Input:
    name: Node name.
Pre:
    Graph should have this node.
Return:
    List of in-neighbor node names.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:get_out_neighbors}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.get\_out\_neighbors \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_out\_neighbors}(\textit{self}, \textit{name})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: get\_out\_neighbors(self, name)
Description:
Returns list of out-neighbors of given node.
Input:
    name: Node name.
Pre:
    Graph should have this node.
Return:
    List of out-neighbor node names.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:edge_to_string}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.edge\_to\_string \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{edge\_to\_string}(\textit{self}, \textit{e})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: edge\_to\_string(self, e)
Description:
Return string that represents edge e in dot language.
Input:
    e: Edge tuple in (source,sink) format.
Pre:
    Graph should have this edge.
Return:
    String that represents given edge.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:to_string}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.to\_string \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{to\_string}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: to\_string(self)
Description:
This method is based on pydot Graph class with the same name.
Returns a string representation of the graph in dot language.
It will return the graph and all its subelements in string form.
Return:
    String that represents graph in dot language.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:label_components}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.label\_components \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{label\_components}(\textit{self}, \textit{display}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: label\_components(self, display=None)
Description:
This method labels the nodes of an undirected graph with component
numbers so that each node has the same label as all nodes in the
same component. It will display the algortihm if display argument is
provided.
Input:
    display: display method.
Pre:
    self.graph\_type should be UNDIRECTED\_GRAPH.
Post:
    Nodes will have 'component' attribute that will have component
    number as value.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:tarjan}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.tarjan \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{tarjan}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: tarjan(self)
Description:
Implements Tarjan's algorithm for determining strongly connected set of
nodes.
Pre:
    self.graph\_type should be DIRECTED\_GRAPH.
Post:
    Nodes will have 'component' attribute that will have component
    number as value. Changes 'index' attribute of nodes.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:strong_connect}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.strong\_connect \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{strong\_connect}(\textit{self}, \textit{q}, \textit{node}, \textit{index}, \textit{component})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: strong\_connect (self, q, node, index, component)
Description:
Used by tarjan method. This method should not be called directly by
user.
Input:
    q: Node list.
    node: Node that is being connected to nodes in q.
    index: Index used by tarjan method.
    component: Current component number.
Pre:
    Should be called by tarjan and itself (recursive) only.
Post:
    Nodes will have 'component' attribute that will have component
    number as value. Changes 'index' attribute of nodes.
Return:
    Returns new index and component numbers.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:label_strong_component}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.label\_strong\_component \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{label\_strong\_component}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: label\_strong\_component(self)
Description:
This method labels the nodes of a directed graph with component
numbers so that each node has the same label as all nodes in the
same component.
Pre:
    self.graph\_type should be DIRECTED\_GRAPH.
Post:
    Nodes will have 'component' attribute that will have component
    number as value. Changes 'index' attribute of nodes.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:dfs}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.dfs \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{dfs}(\textit{self}, \textit{root}, \textit{disc\_count}={\tt 0}, \textit{finish\_count}={\tt 1}, \textit{component}={\tt None}, \textit{transpose}={\tt False}, \textit{display}={\tt None}, \textit{pred}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: dfs(self, root, disc\_count = 0, finish\_count = 1, component=None,
    transpose=False)
Description:
Make a depth-first search starting from node with name root.
Input:
    root: Starting node name.
    disc\_count: Discovery time.
    finish\_count: Finishing time.
    component: component number.
    transpose: Goes in the reverse direction along edges if transpose
    is True.
Post:
    Nodes will have 'component' attribute that will have component
    number as value. Updates 'disc\_time' and 'finish\_time' attributes
    of nodes which represents discovery time and finishing time.
Return:
    Returns a tuple that has discovery time and finish time of the
    last node in the following form (disc\_time,finish\_time).
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:bfs}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.bfs \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{bfs}(\textit{self}, \textit{root}, \textit{display}={\tt None}, \textit{component}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: bfs(self, root, display = None, component=None)
Description:
Make a breadth-first search starting from node with name root.
Input:
    root: Starting node name.
    display: display method.
    component: component number.
Post:
    Nodes will have 'component' attribute that will have component
    number as value.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:search}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.search \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{search}(\textit{self}, \textit{source}, \textit{destination}={\tt None}, \textit{display}={\tt None}, \textit{component}={\tt None}, \textit{q}={\tt None}, \textit{algo}={\tt \texttt{'}\texttt{DFS}\texttt{'}}, \textit{reverse}={\tt False}, **\textit{kargs})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: search(self, source, destination = None, display = None,
       component = None, q = Stack(),
       algo = 'DFS', reverse = False, **kargs)
Description:
Generic search method. Changes behavior (dfs,bfs,dijkstra,prim)
according to algo argument.
if destination is not specified:
   This method determines all nodes reachable from "source" ie. creates
   precedence tree and returns it (dictionary).
if destionation is given:
   If there exists a path from "source" to "destination" it will return
   list of the nodes is this path. If there is no such path, it will
   return the precedence tree constructed from source (dictionary).
Optionally, it marks all nodes reachable from "source" with a component
number. The variable "q" determines the order in which the nodes are
searched.
Input:
    source: Search starts from node with this name.
    destination: Destination node name.
    display: Display method.
    algo: Algortihm that specifies search. Available algortihms are
    'DFS', 'BFS', 'Dijkstra' and 'Prim'.
    reverse: Search goes in reverse arc directions if True.
    kargs: Additional keyword arguments.
Post:
    Nodes will have 'component' attribute that will have component
    number as value (if component argument provided). Color attribute
    of nodes and edges may change.
Return:
    Returns predecessor tree in dictionary form if destination is
    not specified, returns list of node names in the path from source
    to destionation if destionation is specified and there is a path.
    If there is no path returns predecessor tree in dictionary form.
    See description section.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:process_node_search}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.process\_node\_search \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{process\_node\_search}(\textit{self}, \textit{node}, \textit{q}, **\textit{kwargs})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: process\_node\_search(self, node, q, **kwargs)
Description:
Used by search() method. Process nodes along the search. Should not be
called by user directly.
Input:
    node: Name of the node being processed.
    q: Queue data structure.
    kwargs: Keyword arguments.
Post:
    'priority' attribute of the node may get updated.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:process_edge_dijkstra}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.process\_edge\_dijkstra \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{process\_edge\_dijkstra}(\textit{self}, \textit{current}, \textit{neighbor}, \textit{pred}, \textit{q}, \textit{component})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: process\_edge\_dijkstra(self, current, neighbor, pred, q, component)
Description:
Used by search() method if the algo argument is 'Dijkstra'. Processes
edges along Dijkstra's algorithm. User does not need to call this
method directly.
Input:
    current: Name of the current node.
    neighbor: Name of the neighbor node.
    pred: Predecessor tree.
    q: Data structure that holds nodes to be processed in a queue.
    component: component number.
Post:
    'color' attribute of nodes and edges may change.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:process_edge_prim}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.process\_edge\_prim \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{process\_edge\_prim}(\textit{self}, \textit{current}, \textit{neighbor}, \textit{pred}, \textit{q}, \textit{component})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: process\_edge\_prim(self, current, neighbor, pred, q, component)
Description:
Used by search() method if the algo argument is 'Prim'. Processes
edges along Prim's algorithm. User does not need to call this method
directly.
Input:
    current: Name of the current node.
    neighbor: Name of the neighbor node.
    pred: Predecessor tree.
    q: Data structure that holds nodes to be processed in a queue.
    component: component number.
Post:
    'color' attribute of nodes and edges may change.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:process_edge_search}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.process\_edge\_search \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{process\_edge\_search}(\textit{self}, \textit{current}, \textit{neighbor}, \textit{pred}, \textit{q}, \textit{component}, \textit{algo}, **\textit{kargs})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: process\_edge\_search(self, current, neighbor, pred, q, component,
                         algo, **kargs)
Description:
Used by search() method. Processes edges according to the underlying
algortihm. User does not need to call this method directly.
Input:
    current: Name of the current node.
    neighbor: Name of the neighbor node.
    pred: Predecessor tree.
    q: Data structure that holds nodes to be processed in a queue.
    component: component number.
    algo: Search algorithm. See search() documentation.
    kwargs: Keyword arguments.
Post:
    'color', 'distance', 'component' attribute of nodes and edges may
    change.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:minimum_spanning_tree_prim}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.minimum\_spanning\_tree\_prim \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{minimum\_spanning\_tree\_prim}(\textit{self}, \textit{source}, \textit{display}={\tt None}, \textit{q}={\tt PriorityQueue()})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: minimum\_spanning\_tree\_prim(self, source, display = None,
                                q = PriorityQueue())
Description:
Determines a minimum spanning tree of all nodes reachable
from source using Prim's Algorithm.
Input:
    source: Name of source node.
    display: Display method.
    q: Data structure that holds nodes to be processed in a queue.
Post:
    'color', 'distance', 'component' attribute of nodes and edges may
    change.
Return:
    Returns predecessor tree in dictionary format.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:minimum_spanning_tree_kruskal}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.minimum\_spanning\_tree\_kruskal \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{minimum\_spanning\_tree\_kruskal}(\textit{self}, \textit{display}={\tt None}, \textit{components}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: minimum\_spanning\_tree\_kruskal(self, display = None,
                                   components = None)
Description:
Determines a minimum spanning tree using Kruskal's Algorithm.
Input:
    display: Display method.
    component: component number.
Post:
    'color' attribute of nodes and edges may change.
Return:
    Returns list of edges where edges are tuples in (source,sink)
    format.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:max_flow_preflowpush}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.max\_flow\_preflowpush \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{max\_flow\_preflowpush}(\textit{self}, \textit{source}, \textit{sink}, \textit{algo}={\tt \texttt{'}\texttt{FIFO}\texttt{'}}, \textit{display}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: max\_flow\_preflowpush(self, source, sink, algo = 'FIFO',
                          display = None)
Description:
Finds maximum flow from source to sink by a depth-first search based
augmenting path algorithm.
Pre:
     Assumes a directed graph in which each arc has a 'capacity'
     attribute and for which there does does not exist both arcs (i,j)
     and (j,i) for any pair of nodes i and j.
Input:
    source: Source node name.
    sink: Sink node name.
    algo: Algorithm choice, 'FIFO', 'SAP' or 'HighestLabel'.
    display: display method.
Post:
    The 'flow' attribute of each arc gives a maximum flow.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:process_edge_flow}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.process\_edge\_flow \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{process\_edge\_flow}(\textit{self}, \textit{source}, \textit{sink}, \textit{i}, \textit{j}, \textit{algo}, \textit{q})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: process\_edge\_flow(self, source, sink, i, j, algo, q)
Description:
Used by by max\_flow\_preflowpush() method. Processes edges along
prefolow push.
Input:
    source: Source node name of flow graph.
    sink: Sink node name of flow graph.
    i: Source node in the processed edge (tail of arc).
    j: Sink node in the processed edge (head of arc).
Post:
    The 'flow' and 'excess' attributes of nodes may get updated.
Return:
    Returns False if residual capacity is 0, True otherwise.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:relabel}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.relabel \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{relabel}(\textit{self}, \textit{i})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: relabel(self, i)
Description:
Used by max\_flow\_preflowpush() method for relabelling node i.
Input:
    i: Node that is being relabelled.
Post:
    'distance' attribute of node i is updated.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:show_flow}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.show\_flow \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{show\_flow}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: relabel(self, i)
Description:
Used by max\_flow\_preflowpush() method for display purposed.
Post:
    'color' and 'label' attribute of edges/nodes are updated.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:create_residual_graph}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.create\_residual\_graph \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{create\_residual\_graph}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: create\_residual\_graph(self)
Description:
Creates and returns residual graph, which is a Graph instance
itself.
Pre:
    (1) Arcs should have 'flow', 'capacity' and 'cost' attribute
    (2) Graph should be a directed graph
Return:
    Returns residual graph, which is a Graph instance.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:cycle_canceling}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.cycle\_canceling \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{cycle\_canceling}(\textit{self}, \textit{display})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    cycle\_canceling(self, display)
Description:
    Solves minimum cost feasible flow problem using cycle canceling
    algorithm. Returns True when an optimal solution is found, returns
    False otherwise. 'flow' attribute values of arcs should be
    considered as junk when returned False.
Input:
    display: Display method.
Pre:
    (1) Arcs should have 'capacity' and 'cost' attribute.
    (2) Nodes should have 'demand' attribute, this value should be
    positive if the node is a supply node, negative if it is demand
    node and 0 if it is transhipment node.
    (3) graph should not have node 's' and 't'.
Post:
    Changes 'flow' attributes of arcs.
Return:
    Returns True when an optimal solution is found, returns False
    otherwise.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:find_feasible_flow}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.find\_feasible\_flow \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{find\_feasible\_flow}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    find\_feasible\_flow(self)
Description:
    Solves feasible flow problem, stores solution in 'flow' attribute
    or arcs. This method is used to get an initial feasible flow for
    simplex and cycle canceling algorithms. Uses max\_flow() method.
    Other max flow methods can also be used. Returns True if a feasible
    flow is found, returns False, if the problem is infeasible. When
    the problem is infeasible 'flow' attributes of arcs should be
    considered as junk.
Pre:
    (1) 'capacity' attribute of arcs
    (2) 'demand' attribute of nodes
Post:
    Keeps solution in 'flow' attribute of arcs.
Return:
    Returns True if a feasible flow is found, returns False, if the
    problem is infeasible
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:get_layout}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.get\_layout \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_layout}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    get\_layout(self)
Description:
Returns layout attribute of the graph.
Return:
    Returns layout attribute of the graph.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:set_layout}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.set\_layout \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{set\_layout}(\textit{self}, \textit{value})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    set\_layout(self, value)
Description:
Sets layout attribute of the graph to value.
Input:
    value: New value of the layout.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:write}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.write \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{write}(\textit{self}, \textit{basename}={\tt \texttt{'}\texttt{graph}\texttt{'}}, \textit{layout}={\tt None}, \textit{format}={\tt \texttt{'}\texttt{png}\texttt{'}})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    write(self, basename = 'graph', layout = None, format='png')
Description:
Writes graph to dist using layout and format.
Input:
    basename: name of the file that will be written.
    layout: Dot layout for generating graph image.
    format: Image format, all format supported by Dot are wellcome.
Post:
    File will be written to disk.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:create}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.create \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{create}(\textit{self}, \textit{layout}, \textit{format}, **\textit{args})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    create(self, layout, format, **args)
Description:
    Returns postscript representation of graph.
Input:
    layout: Dot layout for generating graph image.
    format: Image format, all format supported by Dot are wellcome.
Return:
    Returns postscript representation of graph.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:display}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.display \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{display}(\textit{self}, \textit{highlight}={\tt None}, \textit{basename}={\tt \texttt{'}\texttt{graph}\texttt{'}}, \textit{format}={\tt \texttt{'}\texttt{png}\texttt{'}}, \textit{pause}={\tt True})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    display(self, highlight = None, basename = 'graph', format = 'png',
        pause = True)
Description:
    Displays graph according to the arguments provided.
    Current display modes: 'off', 'file', 'pygame', 'PIL', 'xdot',
    'svg'
    Current layout modes: Layouts provided by graphviz ('dot', 'fdp',
    'circo', etc.) and 'dot2tex'.
    Current formats: Formats provided by graphviz ('ps', 'pdf', 'png',
    etc.)
Input:
    highlight: List of nodes to be highlighted.
    basename: File name. It will be used if display mode is 'file'.
    format: Image format, all format supported by Dot are wellcome.
    pause: If display is 'pygame' and pause is True pygame will pause
    and wait for user input before closing the display. It will close
    display window straightaway otherwise.
Post:
    A display window will pop up or a file will be written depending
    on display mode.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:set_display_mode}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.set\_display\_mode \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{set\_display\_mode}(\textit{self}, \textit{value})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    set\_display\_mode(self, value)
Description:
    Sets display mode to value.
Input:
    value: New display mode.
Post:
    Display mode attribute of graph is updated.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:max_flow}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.max\_flow \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{max\_flow}(\textit{self}, \textit{source}, \textit{sink}, \textit{display}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API: max\_flow(self, source, sink, display=None)
Description:
Finds maximum flow from source to sink by a depth-first search based
augmenting path algorithm.
Pre:
    Assumes a directed graph in which each arc has a 'capacity'
    attribute and for which there does does not exist both arcs (i,j)
    and (j, i) for any pair of nodes i and j.
Input:
    source: Source node name.
    sink: Sink node name.
    display: Display mode.
Post:
    The 'flow" attribute of each arc gives a maximum flow.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:get_negative_cycle}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.get\_negative\_cycle \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_negative\_cycle}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    get\_negative\_cycle(self)
Description:
    Finds and returns negative cost cycle using 'cost' attribute of
    arcs. Return value is a list of nodes representing cycle it is in
    the following form; n\_1-n\_2-...-n\_k, when the cycle has k nodes.
Pre:
    Arcs should have 'cost' attribute.
Return:
    Returns a list of nodes in the cycle if a negative cycle exists,
    returns None otherwise.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:floyd_warshall}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.floyd\_warshall \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{floyd\_warshall}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    floyd\_warshall(self)
Description:
    Finds all pair shortest paths and stores it in a list of lists.
    This is possible if the graph does not have negative cycles. It will
    return a tuple with 3 elements. The first element indicates whether
    the graph has a negative cycle. It is true if the graph does not
    have a negative cycle, ie. distances found are valid shortest
    distances. The second element is a dictionary of shortest distances
    between nodes. Keys are tuple of node pairs ie. (i,j). The third
    element is a dictionary that helps to retrieve the shortest path
    between nodes. Then return value can be represented as (validity,
    distance, nextn) where nextn is the dictionary to retrieve paths.
    distance and nextn can be used as inputs to other methods to get
    shortest path between nodes.
Pre:
    Arcs should have 'cost' attribute.
Return:
    Returns (validity, distance, nextn). The distances are valid if
    validity is True.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:floyd_warshall_get_path}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.floyd\_warshall\_get\_path \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{floyd\_warshall\_get\_path}(\textit{self}, \textit{distance}, \textit{nextn}, \textit{i}, \textit{j})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    floyd\_warshall\_get\_path(self, distance, nextn, i, j):
Description:
    Finds shortest path between i and j using distance and nextn
    dictionaries.
Pre:
    (1) distance and nextn are outputs of floyd\_warshall method.
    (2) The graph does not have a negative cycle, , ie.
    distance[(i,i)] {\textgreater}=0 for all node i.
Return:
    Returns the list of nodes on the path from i to j, ie. [i,...,j]
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:floyd_warshall_get_cycle}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.floyd\_warshall\_get\_cycle \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{floyd\_warshall\_get\_cycle}(\textit{self}, \textit{distance}, \textit{nextn}, \textit{element}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    floyd\_warshall\_get\_cycle(self, distance, nextn, element = None)
Description:
    Finds a negative cycle in the graph.
Pre:
    (1) distance and nextn are outputs of floyd\_warshall method.
    (2) The graph should have a negative cycle, , ie.
    distance[(i,i)] {\textless} 0 for some node i.
Return:
    Returns the list of nodes on the cycle. Ex: [i,j,k,...,r], where
    (i,j), (j,k) and (r,i) are some edges in the cycle.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:find_cycle_capacity}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.find\_cycle\_capacity \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{find\_cycle\_capacity}(\textit{self}, \textit{cycle})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    find\_cycle\_capacity(self, cycle):
Description:
    Finds capacity of the cycle input.
Pre:
    (1) Arcs should have 'capacity' attribute.
Input:
    cycle: a list representing a cycle
Return:
    Returns an integer number representing capacity of cycle.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:fifo_label_correcting}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.fifo\_label\_correcting \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{fifo\_label\_correcting}(\textit{self}, \textit{source})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    fifo\_label\_correcting(self, source)
Description:
    finds shortest path from source to every other node. Returns
    predecessor dictionary. If graph has a negative cycle, detects it
    and returns to it.
Pre:
    (1) 'cost' attribute of arcs. It will be used to compute shortest
    path.
Input:
    source: source node
Post:
    Modifies 'distance' attribute of nodes.
Return:
    If there is no negative cycle returns to (True, pred), otherwise
    returns to (False, cycle) where pred is the predecessor dictionary
    and cycle is a list of nodes that represents cycle. It is in
    [n\_1, n\_2, ..., n\_k] form where the cycle has k nodes.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:label_correcting_check_cycle}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.label\_correcting\_check\_cycle \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{label\_correcting\_check\_cycle}(\textit{self}, \textit{j}, \textit{pred})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    label\_correcting\_check\_cycle(self, j, pred)
Description:
    Checks if predecessor dictionary has a cycle, j represents the node
    that predecessor is recently updated.
Pre:
    (1) predecessor of source node should be None.
Input:
    j: node that predecessor is recently updated.
    pred: predecessor dictionary
Return:
    If there exists a cycle, returns the list that represents the
    cycle, otherwise it returns to None.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:label_correcting_get_cycle}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.label\_correcting\_get\_cycle \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{label\_correcting\_get\_cycle}(\textit{self}, \textit{j}, \textit{pred})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    label\_correcting\_get\_cycle(self, labelled, pred)
Description:
    In label correcting check cycle it is decided pred has a cycle and
    nodes in the cycle are labelled. We will create a list of nodes
    in the cycle using labelled and pred inputs.
Pre:
    This method should be called from label\_correcting\_check\_cycle(),
    unless you are sure about what you are doing.
Input:
    j: Node that predecessor is recently updated. We know that it is
    in the cycle
    pred: Predecessor dictionary that contains a cycle
Post:
    Returns a list of nodes that represents cycle. It is in
    [n\_1, n\_2, ..., n\_k] form where the cycle has k nodes.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:augment_cycle}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.augment\_cycle \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{augment\_cycle}(\textit{self}, \textit{amount}, \textit{cycle})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    augment\_cycle(self, amount, cycle):
Description:
    Augments 'amount' unit of flow along cycle.
Pre:
    Arcs should have 'flow' attribute.
Inputs:
    amount: An integer representing the amount to augment
    cycle: A list representing a cycle
Post:
    Changes 'flow' attributes of arcs.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:network_simplex}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.network\_simplex \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{network\_simplex}(\textit{self}, \textit{display}, \textit{pivot}, \textit{root})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    network\_simplex(self, display, pivot, root)
Description:
    Solves minimum cost feasible flow problem using network simplex
    algorithm. It is recommended to use min\_cost\_flow(algo='simplex')
    instead of using network\_simplex() directly. Returns True when an
    optimal solution is found, returns False otherwise. 'flow' attribute
    values of arcs should be considered as junk when returned False.
Pre:
    (1) check Pre section of min\_cost\_flow()
Input:
    pivot: specifies pivot rule. Check min\_cost\_flow()
    display: 'off' for no display, 'pygame' for live update of
    spanning tree.
    root: Root node for the underlying spanning trees that will be
    generated by network simplex algorthm.
Post:
    (1) Changes 'flow' attribute of edges.
Return:
    Returns True when an optimal solution is found, returns
    False otherwise.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:simplex_mark_leaving_arc}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.simplex\_mark\_leaving\_arc \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{simplex\_mark\_leaving\_arc}(\textit{self}, \textit{p}, \textit{q})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    simplex\_mark\_leving\_arc(self, p, q)
Description:
    Marks leaving arc.
Input:
    p: tail of the leaving arc
    q: head of the leaving arc
Post:
    Changes color attribute of leaving arc.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:simplex_determine_leaving_arc}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.simplex\_determine\_leaving\_arc \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{simplex\_determine\_leaving\_arc}(\textit{self}, \textit{t}, \textit{k}, \textit{l})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    simplex\_determine\_leaving\_arc(self, t, k, l)
Description:
    Determines and returns the leaving arc.
Input:
    t: current spanning tree solution.
    k: tail of the entering arc.
    l: head of the entering arc.
Return:
    Returns the tuple that represents leaving arc, capacity of the
    cycle and cycle.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:simplex_mark_entering_arc}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.simplex\_mark\_entering\_arc \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{simplex\_mark\_entering\_arc}(\textit{self}, \textit{k}, \textit{l})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    simplex\_mark\_entering\_arc(self, k, l)
Description:
    Marks entering arc (k,l)
Input:
    k: tail of the entering arc
    l: head of the entering arc
Post:
    (1) color attribute of the arc (k,l)
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:simplex_mark_st_arcs}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.simplex\_mark\_st\_arcs \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{simplex\_mark\_st\_arcs}(\textit{self}, \textit{t})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    simplex\_mark\_st\_arcs(self, t)
Description:
    Marks spanning tree arcs.
    Case 1, Blue: Arcs that are at lower bound and in tree.
    Case 2, Red: Arcs that are at upper bound and in tree.
    Case 3, Green: Arcs that are between bounds are green.
    Case 4, Brown: Non-tree arcs at lower bound.
    Case 5, Violet: Non-tree arcs at upper bound.
Input:
    t: t is the current spanning tree
Post:
    (1) color attribute of edges.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:print_flow}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.print\_flow \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{print\_flow}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    print\_flow(self)
Description:
    Prints all positive flows to stdout. This method can be used for
    debugging purposes.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:simplex_redraw}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.simplex\_redraw \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{simplex\_redraw}(\textit{self}, \textit{display}, \textit{root})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    simplex\_redraw(self, display, root)
Description:
    Returns a new graph instance that is same as self but adds nodes
    and arcs in a way that the resulting tree will be displayed
    properly.
Input:
    display: display mode
    root: root node in tree.
Return:
    Returns a graph same as self.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:simplex_remove_arc}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.simplex\_remove\_arc \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{simplex\_remove\_arc}(\textit{self}, \textit{t}, \textit{p}, \textit{q}, \textit{min\_capacity}, \textit{cycle})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    simplex\_remove\_arc(self, p, q, min\_capacity, cycle)
Description:
    Removes arc (p,q), updates t, updates flows, where (k,l) is
    the entering arc.
Input:
    t: tree solution to be updated.
    p: tail of the leaving arc.
    q: head of the leaving arc.
    min\_capacity: capacity of the cycle.
    cycle: cycle obtained when entering arc considered.
Post:
    (1) updates t.
    (2) updates 'flow' attributes.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:simplex_select_entering_arc}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.simplex\_select\_entering\_arc \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{simplex\_select\_entering\_arc}(\textit{self}, \textit{t}, \textit{pivot})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    simplex\_select\_entering\_arc(self, t, pivot)
Description:
    Decides and returns entering arc using pivot rule.
Input:
    t: current spanning tree solution
    pivot: May be one of the following; 'first\_eligible' or 'dantzig'.
    'dantzig' is the default value.
Return:
    Returns entering arc tuple (k,l)
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:simplex_optimal}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.simplex\_optimal \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{simplex\_optimal}(\textit{self}, \textit{t})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    simplex\_optimal(self, t)
Description:
    Checks if the current solution is optimal, if yes returns True,
    False otherwise.
Pre:
    'flow' attributes represents a solution.
Input:
    t: Graph instance tat reperesents spanning tree solution.
Return:
    Returns True if the current solution is optimal (optimality
    conditions are satisfied), else returns False
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:simplex_find_tree}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.simplex\_find\_tree \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{simplex\_find\_tree}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    simplex\_find\_tree(self)
Description:
    Assumes a feasible flow solution stored in 'flow' attribute's of
    arcs and converts this solution to a feasible spanning tree
    solution.
Pre:
    (1) 'flow' attributes represents a feasible flow solution.
Post:
    (1) 'flow' attributes may change when eliminating cycles.
Return:
    Return a Graph instance that is a spanning tree solution.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:simplex_connect}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.simplex\_connect \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{simplex\_connect}(\textit{self}, \textit{solution\_g})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    simplex\_connect(self, solution\_g)
Description:
    At this point we assume that the solution does not have a cycle.
    We check if all the nodes are connected, if not we add an arc to
    solution\_g that does not create a cycle and return True. Otherwise
    we do nothing and return False.
Pre:
    (1) We assume there is no cycle in the solution.
Input:
    solution\_g: current spanning tree solution instance.
Post:
    (1) solution\_g is updated. An arc that does not create a cycle is
    added.
    (2) 'component' attribute of nodes are changed.
Return:
    Returns True if an arc is added, returns False otherwise.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:simplex_search}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.simplex\_search \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{simplex\_search}(\textit{self}, \textit{source}, \textit{component\_nr})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    simplex\_search(self, source, component\_nr)
Description:
    Searches graph starting from source. Its difference from usual
    search is we can also go backwards along an arc. When the graph
    is a spanning tree it computes predecessor, thread and depth
    indexes and stores them as node attributes. These values should be
    considered as junk when the graph is not a spanning tree.
Input:
    source: source node
    component\_nr: component number
Post:
    (1) Sets the component number of all reachable nodes to component.
    Changes 'component' attribute of nodes.
    (2) Sets 'pred', 'thread' and 'depth' attributes of nodes. These
    values are junk if the graph is not a tree.
Return:
    Returns predecessor dictionary.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:simplex_augment_cycle}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.simplex\_augment\_cycle \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{simplex\_augment\_cycle}(\textit{self}, \textit{cycle})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    simplex\_augment\_cycle(self, cycle)
Description:
    Augments along the cycle to break it.
Pre:
    'flow', 'capacity' attributes on arcs.
Input:
    cycle: list representing a cycle in the solution
Post:
    'flow' attribute will be modified.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:simplex_find_cycle}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.simplex\_find\_cycle \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{simplex\_find\_cycle}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    simplex\_find\_cycle(self)
Description:
    Returns a cycle (list of nodes) if the graph has one, returns None
    otherwise. Uses DFS. During DFS checks existence of arcs to lower
    depth regions. Note that direction of the arcs are not important.
Return:
    Returns list of nodes that represents cycle. Returns None if the
    graph does not have any cycle.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:get_simplex_solution_graph}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.get\_simplex\_solution\_graph \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_simplex\_solution\_graph}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    get\_simplex\_solution\_graph(self):
Description:
    Assumes a feasible flow solution stored in 'flow' attribute's of
    arcs. Returns the graph with arcs that have flow between 0 and
    capacity.
Pre:
    (1) 'flow' attribute represents a feasible flow solution. See
    Pre section of min\_cost\_flow() for details.
Return:
    Graph instance that only has the arcs that have flow strictly
    between 0 and capacity.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:simplex_compute_potentials}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.simplex\_compute\_potentials \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{simplex\_compute\_potentials}(\textit{self}, \textit{t}, \textit{root})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    simplex\_compute\_potentials(self, t, root)
Description:
    Computes node potentials for a minimum cost flow problem and stores
    them as node attribute 'potential'. Based on pseudocode given in
    Network Flows by Ahuja et al.
Pre:
    (1) Assumes a directed graph in which each arc has a 'cost'
    attribute.
    (2) Uses 'thread' and 'pred' attributes of nodes.
Input:
    t: Current spanning tree solution, its type is Graph.
    root: root node of the tree.
Post:
    Keeps the node potentials as 'potential' attribute.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:simplex_identify_cycle}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.simplex\_identify\_cycle \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{simplex\_identify\_cycle}(\textit{self}, \textit{t}, \textit{k}, \textit{l})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    identify\_cycle(self, t, k, l)
Description:
    Identifies and returns to the pivot cycle, which is a list of
    nodes.
Pre:
    (1) t is spanning tree solution, (k,l) is the entering arc.
Input:
    t: current spanning tree solution
    k: tail of the entering arc
    l: head of the entering arc
Returns:
    List of nodes in the cycle.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:min_cost_flow}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.min\_cost\_flow \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{min\_cost\_flow}(\textit{self}, \textit{display}={\tt None}, **\textit{args})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    min\_cost\_flow(self, display='off', **args)
Description:
    Solves minimum cost flow problem using node/edge attributes with
    the algorithm specified.
Pre:
    (1) Assumes a directed graph in which each arc has 'capacity' and
    'cost' attributes.
    (2) Nodes should have 'demand' attribute. This value should be
    positive for supply and negative for demand, and 0 for transhipment
    nodes.
    (3) The graph should be connected.
    (4) Assumes (i,j) and (j,i) does not exist together. Needed when
    solving max flow. (max flow problem is solved to get a feasible
    flow).
Input:
    display: 'off' for no display, 'pygame' for live update of tree
    args: may have the following
        display: display method, if not given current mode (the one
            specified by \_\_init\_\_ or set\_display) will be used.
        algo: determines algorithm to use, can be one of the following
            'simplex': network simplex algorithm
            'cycle\_canceling': cycle canceling algorithm
            'simplex' is used if not given.
            see Network Flows by Ahuja et al. for details of algorithms.
        pivot: valid if algo is 'simlex', determines pivoting rule for
            simplex, may be one of the following; 'first\_eligible',
            'dantzig' or 'scaled'.
            'dantzig' is used if not given.
            see Network Flows by Ahuja et al. for pivot rules.
        root: valid if algo is 'simlex', specifies the root node for
            simplex algorithm. It is name of the one of the nodes. It
            will be chosen randomly if not provided.
Post:
    The 'flow' attribute of each arc gives the optimal flows.
    'distance' attribute of the nodes are also changed during max flow
    solution process.
Examples:
    g.min\_cost\_flow():
        solves minimum cost feasible flow problem using simplex
        algorithm with dantzig pivoting rule.
        See pre section for details.
    g.min\_cost\_flow(algo='cycle\_canceling'):
        solves minimum cost feasible flow problem using cycle canceling
        agorithm.
    g.min\_cost\_flow(algo='simplex', pivot='scaled'):
        solves minimum cost feasible flow problem using network simplex
        agorithm with scaled pivot rule.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:random}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.random \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{random}(\textit{self}, \textit{numnodes}={\tt 10}, \textit{degree\_range}={\tt \texttt{(}2\texttt{, }4\texttt{)}}, \textit{length\_range}={\tt \texttt{(}1\texttt{, }10\texttt{)}}, \textit{density}={\tt None}, \textit{edge\_format}={\tt None}, \textit{node\_format}={\tt None}, \textit{Euclidean}={\tt False}, \textit{seedInput}={\tt 0}, \textit{add\_labels}={\tt True}, \textit{parallel\_allowed}={\tt False}, \textit{node\_selection}={\tt \texttt{'}\texttt{closest}\texttt{'}}, \textit{scale}={\tt 10}, \textit{scale\_cost}={\tt 5})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    random(self, numnodes = 10, degree\_range = None, length\_range = None,
       density = None, edge\_format = None, node\_format = None,
       Euclidean = False, seedInput = 0)
Description:
    Populates graph with random edges and nodes.
Input:
    numnodes: Number of nodes to add.
    degree\_range: A tuple that has lower and upper bounds of degree for
    a node.
    length\_range: A tuple that has lower and upper bounds for 'cost'
    attribute of edges.
    density: Density of edges, ie. 0.5 indicates a node will
    approximately have edge to half of the other nodes.
    edge\_format: Dictionary that specifies attribute values for edges.
    node\_format: Dictionary that specifies attribute values for nodes.
    Euclidean: Creates an Euclidean graph (Euclidean distance between
    nodes) if True.
    seedInput: Seed that will be used for random number generation.
Pre:
    It is recommended to call this method on empty Graph objects.
Post:
    Graph will be populated by nodes and edges.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:page_rank}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.page\_rank \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{page\_rank}(\textit{self}, \textit{damping\_factor}={\tt 0.85}, \textit{max\_iterations}={\tt 100}, \textit{min\_delta}={\tt 1e-05})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    page\_rank(self, damping\_factor=0.85, max\_iterations=100,
          min\_delta=0.00001)
Description:
    Compute and return the page-rank of a directed graph.
    This function was originally taken from here and modified for this
    graph class: http://code.google.com/p/python-graph/source/browse/
    trunk/core/pygraph/algorithms/pagerank.py
Input:
    damping\_factor: Damping factor.
    max\_iterations: Maximum number of iterations.
    min\_delta: Smallest variation required to have a new iteration.
Pre:
    Graph should be a directed graph.
Return:
    Returns dictionary of page-ranks. Keys are node names, values are
    corresponding page-ranks.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:get_degree}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.get\_degree \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_degree}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    get\_degree(self)
Description:
    Returns degrees of nodes in dictionary format.
Return:
    Returns a dictionary of node degrees. Keys are node names, values
    are corresponding degrees.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:get_diameter}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.get\_diameter \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_diameter}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    get\_diameter(self)
Description:
    Returns diameter of the graph. Diameter is defined as follows.
    distance(n,m): shortest unweighted path from n to m
    eccentricity(n) = \${\textbackslash}max \_m distance(n,m)\$
    diameter = \${\textbackslash}min \_n eccentricity(n) = {\textbackslash}min \_n {\textbackslash}max \_m distance(n,m)\$
Return:
    Returns diameter of the graph.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:Graph:create_cluster}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}!coinor.gimpy.graph.Graph.create\_cluster \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{create\_cluster}(\textit{self}, \textit{node\_list}, \textit{cluster\_attrs}={\tt \texttt{\{}\texttt{\}}}, \textit{node\_attrs}={\tt \texttt{\{}\texttt{\}}})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    create\_cluster(self, node\_list, cluster\_attrs, node\_attrs)
Description:
    Creates a cluster from the node given in the node list.
Input:
    node\_list: List of nodes in the cluster.
    cluster\_attrs: Dictionary of cluster attributes, see Dot language
    grammer documentation for details.
    node\_attrs: Dictionary of node attributes. It will overwrite
    previous attributes of the nodes in the cluster.
Post:
    A cluster will be created. Attributes of the nodes in the cluster
    may change.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}


\large{\textbf{\textit{Inherited from object}}}

\begin{quote}
\_\_delattr\_\_(), \_\_format\_\_(), \_\_getattribute\_\_(), \_\_hash\_\_(), \_\_new\_\_(), \_\_reduce\_\_(), \_\_reduce\_ex\_\_(), \_\_setattr\_\_(), \_\_sizeof\_\_(), \_\_str\_\_(), \_\_subclasshook\_\_()
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                              Properties                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Properties}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\multicolumn{2}{|l|}{\textit{Inherited from object}}\\
\multicolumn{2}{|p{\varwidth}|}{\raggedright \_\_class\_\_}\\
\cline{1-2}
\end{longtable}

    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.Graph \textit{(class)}|)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.DisjointSet \textit{(class)}|(}
\subsection{Class DisjointSet}

    \label{coinor:gimpy:graph:DisjointSet}
\begin{tabular}{cccccccc}
% Line for object, linespec=[False, False]
\multicolumn{2}{r}{\settowidth{\BCL}{object}\multirow{2}{\BCL}{object}}
&&
&&
  \\\cline{3-3}
  &&\multicolumn{1}{c|}{}
&&
&&
  \\
% Line for coinor.gimpy.graph.Graph, linespec=[False]
\multicolumn{4}{r}{\settowidth{\BCL}{coinor.gimpy.graph.Graph}\multirow{2}{\BCL}{coinor.gimpy.graph.Graph}}
&&
  \\\cline{5-5}
  &&&&\multicolumn{1}{c|}{}
&&
  \\
&&&&\multicolumn{2}{l}{\textbf{coinor.gimpy.graph.DisjointSet}}
\end{tabular}

Disjoint set data structure. Inherits Graph class.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_init\_\_}(\textit{self}, \textit{optimize}={\tt True}, **\textit{attrs})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    \_\_init\_\_(self, optimize = True, **attrs):
Description:
    Class constructor.
Input:
    optimize: Optimizes find() if True.
    attrs: Graph attributes.
Post:
    self.optimize will be updated.
\end{alltt}

\setlength{\parskip}{1ex}
      Overrides: object.\_\_init\_\_

    \end{boxedminipage}

    \label{coinor:gimpy:graph:DisjointSet:add}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.DisjointSet \textit{(class)}!coinor.gimpy.graph.DisjointSet.add \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{add}(\textit{self}, \textit{aList})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    add(self, aList)
Description:
    Adds items in the list to the set.
Input:
    aList: List of items.
Post:
    self.sizes will be updated.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:DisjointSet:union}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.DisjointSet \textit{(class)}!coinor.gimpy.graph.DisjointSet.union \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{union}(\textit{self}, \textit{i}, \textit{j})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    union(self, i, j):
Description:
    Finds sets of i and j and unites them.
Input:
    i: Item.
    j: Item.
Post:
    self.sizes will be updated.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{coinor:gimpy:graph:DisjointSet:find}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.DisjointSet \textit{(class)}!coinor.gimpy.graph.DisjointSet.find \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{find}(\textit{self}, \textit{i})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
\begin{alltt}

API:
    find(self, i)
Description:
    Returns root of set that has i.
Input:
    i: Item.
Return:
    Returns root of set that has i.
\end{alltt}

\setlength{\parskip}{1ex}
    \end{boxedminipage}


\large{\textbf{\textit{Inherited from coinor.gimpy.graph.Graph\textit{(Section \ref{coinor:gimpy:graph:Graph})}}}}

\begin{quote}
\_\_repr\_\_(), add\_edge(), add\_node(), augment\_cycle(), bfs(), check\_edge(), create(), create\_cluster(), create\_residual\_graph(), cycle\_canceling(), del\_edge(), del\_node(), dfs(), display(), edge\_to\_string(), fifo\_label\_correcting(), find\_cycle\_capacity(), find\_feasible\_flow(), floyd\_warshall(), floyd\_warshall\_get\_cycle(), floyd\_warshall\_get\_path(), get\_degree(), get\_diameter(), get\_edge\_attr(), get\_edge\_cost(), get\_edge\_list(), get\_edge\_num(), get\_in\_neighbors(), get\_layout(), get\_negative\_cycle(), get\_neighbors(), get\_node(), get\_node\_attr(), get\_node\_list(), get\_node\_num(), get\_out\_neighbors(), get\_simplex\_solution\_graph(), label\_components(), label\_correcting\_check\_cycle(), label\_correcting\_get\_cycle(), label\_strong\_component(), max\_flow(), max\_flow\_preflowpush(), min\_cost\_flow(), minimum\_spanning\_tree\_kruskal(), minimum\_spanning\_tree\_prim(), network\_simplex(), page\_rank(), print\_flow(), process\_edge\_dijkstra(), process\_edge\_flow(), process\_edge\_prim(), process\_edge\_search(), process\_node\_search(), random(), relabel(), search(), set\_display\_mode(), set\_edge\_attr(), set\_layout(), set\_node\_attr(), show\_flow(), simplex\_augment\_cycle(), simplex\_compute\_potentials(), simplex\_connect(), simplex\_determine\_leaving\_arc(), simplex\_find\_cycle(), simplex\_find\_tree(), simplex\_identify\_cycle(), simplex\_mark\_entering\_arc(), simplex\_mark\_leaving\_arc(), simplex\_mark\_st\_arcs(), simplex\_optimal(), simplex\_redraw(), simplex\_remove\_arc(), simplex\_search(), simplex\_select\_entering\_arc(), strong\_connect(), tarjan(), to\_string(), write()
\end{quote}

\large{\textbf{\textit{Inherited from object}}}

\begin{quote}
\_\_delattr\_\_(), \_\_format\_\_(), \_\_getattribute\_\_(), \_\_hash\_\_(), \_\_new\_\_(), \_\_reduce\_\_(), \_\_reduce\_ex\_\_(), \_\_setattr\_\_(), \_\_sizeof\_\_(), \_\_str\_\_(), \_\_subclasshook\_\_()
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                              Properties                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Properties}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\multicolumn{2}{|l|}{\textit{Inherited from object}}\\
\multicolumn{2}{|p{\varwidth}|}{\raggedright \_\_class\_\_}\\
\cline{1-2}
\end{longtable}

    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}!coinor.gimpy.graph.DisjointSet \textit{(class)}|)}
    \index{coinor \textit{(package)}!coinor.gimpy \textit{(package)}!coinor.gimpy.graph \textit{(module)}|)}
